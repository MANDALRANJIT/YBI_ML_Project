# -*- coding: utf-8 -*-
"""Movie Recommendation

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1t1xS5hk9DhczBS48v6vGE_rh9qNwk7kc

# **Movie Recommendation System**

**Recommender System** is a system that seeks to predict or filter preferences according to the user's choices. Recommender systems are utilized in a variety of areas Including movies, music, news, books, research articles, search queries, social tags, and products in general. Recommender systems produce a list of recommendations in any of the two ways -

**Collaborative filtering:** Collaborative filtering approaches build a model from the user's past behavior (i.e. items purchased or searched by the user) as well as similar decisions made by other users. This model is then used to predict items (or ratings for items) that users may have an Interest in.

**Content-based filtering:** Content-based filtering approaches uses a series of discrete characteristics of an item in order to recommend additional items with similar properties. Content-based filtering methods are totally based on a description of the item and a profile of the user's preferences. It recommends items based on the user's past preferences. Let's develop a basic recommendation system using Python and Pandas.

Let's develop a basic recommendation system by suggesting items that are most similar to a particular item, in this case, movies. It just tells what movies/items are most similar to the user's movie choice

# **Objectives**

**Objective One:** To Analyze and Compare Recommender System Approaches

**Objective Two:** To Develop a Collaborative Filtering Model for Movie Recommendations

**Objective Three:** To Develop a Content-Based Filtering Model for Movie Recommendations

**Objective Four:** To Integrate and Compare Both Filtering Techniques

**Objective Five:** To Provide Insights and Recommendations for Future Research and Development

# **Import Library**
"""

import pandas as pd
import numpy as np

"""# **Import Dataset**"""

df = pd.read_csv(r'https://raw.githubusercontent.com/YBI-Foundation/Dataset/main/Movies%20Recommendation.csv')

df.head()

"""# **Data** **Descriptions**"""

df.info()

df.shape

df.columns

df.describe()

"""# **Missing Value Identification**"""

df.isnull().sum()

"""# **Dealing with the Missing Values**
Based on my initial analysis using df.isnull().sum(), I have identified several columns with missing values, including ***Movie_Runtime, Movie_Homepage, Movie_Keywords, Movie_Overview, Movie_Tagline, Movie_Cast, and Movie_Director***. My approach to handling these missing values is as follows:


**Numerical Columns:** For columns with a small number of missing values, such as ***Movie_Runtime***, I will fill the missing values using the median. This approach minimizes the impact of outliers and preserves the central tendency of the data.

**Dropping Columns:** For columns with a high percentage of missing values, such as ***Movie_Homepage***, I will drop the column. This decision is based on the assumption that the column does not contain critical information for the analysis or model.

**Categorical/Text Columns:** For columns with textual data, such as ***Movie_Keywords, Movie_Overview, Movie_Tagline, Movie_Cast, and Movie_Director***, I will fill the missing values with appropriate placeholder strings. This ensures that all records remain complete and that the placeholders can be easily identified and handled during the analysis and modeling phases.

*By addressing the missing values in this manner, I aim to maintain the integrity of the dataset, enabling to perform comprehensive **exploratory data analysis** (EDA) and develop a reliable **machine learning model**.*
"""

# Filling missing values for numerical columns
df['Movie_Runtime'].fillna(df['Movie_Runtime'].median(), inplace=True)

# Dropping the Movie_Homepage column as it has a high percentage of missing values
df.drop(columns=['Movie_Homepage'], inplace=True)

# Filling missing values for categorical/text columns with placeholders
df['Movie_Keywords'].fillna('No Keywords', inplace=True)
df['Movie_Overview'].fillna('No Overview', inplace=True)
df['Movie_Tagline'].fillna('No Tagline', inplace=True)
df['Movie_Cast'].fillna('No Cast', inplace=True)
df['Movie_Director'].fillna('No Director', inplace=True)

print(df.isnull().sum())

df.info()

"""# **Get Feature Selection**"""

df_features = df[['Movie_Genre', 'Movie_Keywords', 'Movie_Tagline', 'Movie_Cast', 'Movie_Director']]
df_features.head()

df_features.shape

"""The below  operation is commonly used in text processing tasks where multiple text fields need to be combined into a single text field for tasks such as text vectorization, sentiment analysis, or any other natural language processing (NLP) tasks."""

X = df_features['Movie_Genre'] + ' ' + df_features['Movie_Keywords'] + ' ' + df_features['Movie_Tagline'] + ' ' +  df_features['Movie_Cast'] + ' ' + df_features['Movie_Director']
print(X)
print('\n')
print(f'The shape of X is {X.shape}')

"""# **Get Feature Text Conversion to Tokens**"""

from sklearn.feature_extraction.text import TfidfVectorizer

tfidf = TfidfVectorizer()

X = tfidf.fit_transform(X)

X.shape
print('\n')
print(X)

"""# **Get Similarity Score Using Cosine Similarity**

In the context of text data represented as TF-IDF vectors (which I just obtained using TfidfVectorizer), cosine similarity measures the cosine of the angle between two vectors representing two different documents. The resulting value ranges between -1 and 1.

**Note:** *Document means row and feature means column*
"""

from sklearn.metrics.pairwise import cosine_similarity

Similarity_score = cosine_similarity(X)
print('\n')
print(Similarity_score)

print('\n')
print(f'The Shape of the similarity_score is {Similarity_score.shape}')

"""# **Get Movie Name as Input from User and Validate for Closest Spelling**"""

Favourite_Movie_Name = input('Enter your favourite movie name : ')

All_movies_Title_List = df['Movie_Title'].tolist()

import difflib

Movie_Recommendation = difflib.get_close_matches(Favourite_Movie_Name, All_movies_Title_List)
print(Movie_Recommendation)

Close_Match = Movie_Recommendation[0]
print(Close_Match)

Index_of_Close_Match_Movie = df[df.Movie_Title == Close_Match]['Movie_ID'].values[0]
print(Index_of_Close_Match_Movie)

#getting a list of similar movies

Recommendation_Score = list(enumerate(Similarity_score[Index_of_Close_Match_Movie]))
Recommendation_Score

len(Recommendation_Score)

"""# **Get all Movies Sorted Based on Recommendation Score wrt favourite Movie**"""

# sorting the movies based on their sorting score
Sorted_similar_movies = sorted(Recommendation_Score, key = lambda X:X[1], reverse = True)
print(Sorted_similar_movies)

# print thename of the movies based on their index

print("Top 30 movies suggested for you : \n")

i = 1
for movie in Sorted_similar_movies:
      index = movie[0]
      title_from_index = df[df.index==index]['Movie_Title'].values[0]
      if (i<31):
        print(i, '_',title_from_index)
        i+=1

"""# **Top 10 Movie Recommendation System**"""

Movie_Name = input("Enter your favourite movie name please")
list_of_all_titles = df['Movie_Title'].tolist()
Find_Close_Match = difflib.get_close_matches(Movie_Name, list_of_all_titles)
Close_Match = Find_Close_Match[0]
Index_of_Movie = df[df.Movie_Title == Close_Match]['Movie_ID'].values[0]
Recommendation_Score = list(enumerate(Similarity_score[Index_of_Movie]))
sorted_similar_movies = sorted(Recommendation_Score, key = lambda x:x[1], reverse =True)
print('Top 10 Movies Suggested for You : \n')

i = 1
for movie in sorted_similar_movies:
      index = movie[0]
      title_from_index = df[df.index==index]['Movie_Title'].values[0]
      if (i<11):
        print(i, '.',title_from_index)
        i+=1













